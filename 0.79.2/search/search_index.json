{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>di</code>: dependency injection toolkit","text":"<p><code>di</code> is a modern dependency injection toolkit, modeled around the simplicity of FastAPI's dependency injection.</p> <p>Key features:</p> <ul> <li>Intuitive: simple API, inspired by FastAPI.</li> <li>Auto-wiring: <code>di</code> supports auto-wiring using type annotations.</li> <li>Scopes: inspired by pytest scopes, but defined by users (no fixed \"request\" or \"session\" scopes).</li> <li>Composable: decoupled internal APIs give you the flexibility to customize wiring, execution and binding.</li> <li>Performant: <code>di</code> can execute dependencies in parallel and cache results ins scopes. Performance critical parts are written in \ud83e\udd80 via graphlib2.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install di[anyio]\n</code></pre> <p>\u26a0\ufe0f This project is a work in progress. Until there is 1.X.Y release, expect breaking changes. \u26a0\ufe0f</p>"},{"location":"#simple-example","title":"Simple Example","text":"<p>Here is a simple example of how <code>di</code> works:</p> <pre><code>from dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\nclass A:\n    ...\n\n\nclass B:\n    ...\n\n\n@dataclass\nclass C:\n    a: A\n    b: B\n\n\ndef main():\n    container = Container()\n    executor = SyncExecutor()\n    solved = container.solve(Dependent(C, scope=\"request\"), scopes=[\"request\"])\n    with container.enter_scope(\"request\") as state:\n        c = solved.execute_sync(executor=executor, state=state)\n    assert isinstance(c, C)\n    assert isinstance(c.a, A)\n    assert isinstance(c.b, B)\n</code></pre> <p>For more examples, see our docs.</p>"},{"location":"#why-do-i-need-dependency-injection-in-python-isnt-that-a-java-thing","title":"Why do I need dependency injection in Python? Isn't that a Java thing?","text":"<p>Dependency injection is a software architecture technique that helps us achieve inversion of control and dependency inversion (one of the five SOLID design principles).</p> <p>It is a common misconception that traditional software design principles do not apply to Python. As a matter of fact, you are probably using a lot of these techniques already!</p> <p>For example, the <code>transport</code> argument to httpx's Client (docs) is an excellent example of dependency injection. Pytest, arguably the most popular Python test framework, uses dependency injection in the form of pytest fixtures.</p> <p>Most web frameworks employ inversion of control: when you define a view / controller, the web framework calls you! The same thing applies to CLIs (like click) or TUIs (like Textual). This is especially true for many newer web frameworks that not only use inversion of control but also dependency injection. Two great examples of this are FastAPI and BlackSheep.</p> <p>For a more comprehensive overview of Python projects related to dependency injection, see Awesome Dependency Injection in Python.</p>"},{"location":"#project-aims","title":"Project Aims","text":"<p>This project aims to be a dependency injection toolkit, with a focus on providing the underlying dependency injection functionality for other libraries.</p> <p>In other words, while you could use this as a standalone dependency injection framework, you may find it to be a bit terse and verbose. There are also much more mature standalone dependency injection frameworks; I would recommend at least looking into python-dependency-injector since it is currently the most popular / widely used of the bunch.</p> <p>For more background, see our docs.</p>"},{"location":"api/","title":"API Interface","text":""},{"location":"api/#classes","title":"Classes","text":""},{"location":"api/#di.Container","title":"<code>di.Container</code>","text":"<p>Solve and execute dependencies.</p> <p>Generally you will want one Container per application. There is not performance advantage to re-using a container, the only reason to do so is to share binds. For each \"thing\" you want to wire with di and execute you'll want to call <code>Container.solve()</code> exactly once and then keep a reference to the returned <code>SolvedDependent</code> to pass to <code>Container.execute</code>. Solving is very expensive so avoid doing it in a hot loop.</p>"},{"location":"api/#di.Container.bind","title":"<code>bind(hook)</code>","text":"<p>Replace a dependency provider with a new one.</p> <p>This can be used as a function (for a permanent bind, cleared when <code>scope</code> is exited) or as a context manager (the bind will be cleared when the context manager exits).</p>"},{"location":"api/#di.Container.execute_async","title":"<code>execute_async(solved, executor, *, state, values=None)</code>  <code>async</code>","text":"<p>Execute an already solved dependency.</p>"},{"location":"api/#di.Container.execute_sync","title":"<code>execute_sync(solved, executor, *, state, values=None)</code>","text":"<p>Execute an already solved dependency. This method is synchronous and uses a synchronous executor, but the executor may still be able to execute async dependencies.</p>"},{"location":"api/#di.Container.solve","title":"<code>solve(dependency, scopes, scope_resolver=None)</code>","text":"<p>Build the dependency graph.</p> <p>Should happen once, maybe during startup.</p> <p>Solving dependencies can be slow.</p>"},{"location":"api/#di.dependent.Marker","title":"<code>di.dependent.Marker</code>","text":"<p>A dependency marker holds information about a dependency.</p> <p>Used to tell <code>di</code> how to construct another class.</p> <p>For example:</p> <pre><code>def endpoint(conn: Annotated[DBConn, Marker(inject_db, scope=\"request\")]):\n    ...\n</code></pre> <p>Building your own <code>Marker</code> can be critical to enable nice functionality. You could for example create a custom <code>Marker</code> \"Header\" than knows how to construct a <code>str</code> from the headers of a request. Resulting in:</p> <pre><code>def endpoint(content_type: FromHeader[str]):\n    ...\n</code></pre> <p>See more in dependency-markers.</p>"},{"location":"api/#di.dependent.Marker.register_parameter","title":"<code>register_parameter(param)</code>","text":"<p>Hook to register the parameter this Dependent corresponds to.</p> <p>This can be used to inferr self.call from a type annotation (autowiring), or to just register the type annotation.</p> <p>This method can return the same or a new instance of a Dependent to avoid modifying itself.</p>"},{"location":"api/#di.dependent.Dependent","title":"<code>di.dependent.Dependent</code>","text":"<p>Connect dependencies together.</p> <p>A <code>Dependent</code> can have sub-dependencies (also <code>Dependent</code>s). The first argument is a <code>Callable</code>, which is used to find the sub-dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>DependencyProviderType[T] | None</code> <p>used to find subdependencies</p> <code>None</code> <code>wire</code> <code>bool</code> <p>if True then <code>call</code> is introspected to find sub-dependencies.</p> <code>True</code> <code>scope</code> <code>Scope</code> <p>the Scope for this dependency (see https://www.adriangb.com/di/latest/scopes/)</p> <code>None</code> <code>marker</code> <code>Marker | None</code> <p>the Marker from which this Defendant was constructed. This is included only for introspection purposes.</p> <code>None</code>"},{"location":"api/#di.dependent.Dependent.get_dependencies","title":"<code>get_dependencies()</code>","text":"<p>Collect all of our sub-dependencies as parameters</p>"},{"location":"api/#di.executors.SyncExecutor","title":"<code>di.executors.SyncExecutor</code>","text":"<p>An executor that executes only sync dependencies.</p> <p>Dependencies are executed sequentially. If any async dependencies are encountered a RuntimeError will be raised. If there are no async dependencies, this will be faster than using <code>AsyncExecutor</code> because there is no event loop overhead.</p>"},{"location":"api/#di.executors.AsyncExecutor","title":"<code>di.executors.AsyncExecutor</code>","text":"<p>An executor that executes sync and async dependencies sequentially.</p>"},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#di.bind_by_type","title":"<code>di.bind_by_type(provider, dependency, *, covariant=False)</code>","text":"<p>Hook to substitute the matched dependency</p>"},{"location":"architecture/","title":"Architecture","text":"<p>The fundamental design principle of <code>di</code> is to split up the complexity of dependency injection into smaller component parts:</p> <ul> <li>Wiring: when we discover the dependencies. This includes doing reflection (inspecting signatures), looking for dependency markers, etc.</li> <li>Solving: when we build an execution plan, taking into account binds.</li> <li>Execution: when we execute dependencies, possibly doing IO, parallelization, etc.</li> </ul> <p>We map these responsibilities to well-defined classes/interfaces:</p> <ul> <li>Wiring: this is handled by Dependent</li> <li>Solving: this is handled by Container</li> <li>Execution: this is handled by Executors</li> </ul> <p>There are also some auxiliary support classes:</p> <ul> <li>SolvedDependent holds a reference of the result of solving (an executable DAG) that can then be executed at a later time.</li> </ul> <p>Fundamentally, our class diagram looks like this:</p> <p></p> Mermaid diagram source <pre><code>classDiagram\n    SolvedDependent \"1..n\" --o Dependent: aggregates into a DAG\n    Container --&gt; Dependent: visits sub-dependencies\n    Container --&gt; Executor: delegates execution\n    Container --&gt; SolvedDependent: stores solved DAG\n    Container --&gt; SolvedDependent: executes solved DAG\n    class Dependent{\n      +get_dependencies() list~Dependent~\n      +register_parameter() Dependent\n    }\n    class SolvedDependent{\n      +dag Mapping~Dependent, SetOfDependent~\n    }\n    class Executor{\n      +execute()\n    }\n    class Container{\n      +bind()\n      +enter_scope(Scope) Container\n      +solve(Dependent) SolvedDependent\n      +execute(SolvedDependent, Executor) Result\n    }\n</code></pre>"},{"location":"binds/","title":"Binds","text":"<p>Provider binding serves two important functions:</p> <ul> <li>A way to tell the container how to assemble things that can't be auto-wired, for example interfaces.</li> <li>A way to override dependencies in tests.</li> </ul> <p>Every bind in <code>di</code> consists of:</p> <ul> <li>A target callable: this can be a function, an interface / protocol or a concrete class</li> <li>A substitute dependency: an object implementing the <code>DependentBase</code>, usually just an instance of <code>Dependent</code></li> </ul> <p>This means that binds are themselves dependencies:</p> <pre><code>from dataclasses import dataclass\nfrom typing import Protocol\n\nfrom di import Container, bind_by_type\nfrom di.dependent import Dependent\nfrom di.executors import AsyncExecutor\n\n\nclass DBProtocol(Protocol):\n    async def execute(self, sql: str) -&gt; None:\n        ...\n\n\nasync def controller(db: DBProtocol) -&gt; None:\n    await db.execute(\"SELECT *\")\n\n\n@dataclass\nclass DBConfig:\n    host: str = \"localhost\"\n\n\nclass Postgres(DBProtocol):\n    def __init__(self, config: DBConfig) -&gt; None:\n        self.host = config.host\n\n    async def execute(self, sql: str) -&gt; None:\n        print(sql)\n\n\nasync def framework() -&gt; None:\n    container = Container()\n    container.bind(bind_by_type(Dependent(Postgres, scope=\"request\"), DBProtocol))\n    solved = container.solve(Dependent(controller, scope=\"request\"), scopes=[\"request\"])\n    # this next line would fail without the bind\n    async with container.enter_scope(\"request\") as state:\n        await solved.execute_async(executor=AsyncExecutor(), state=state)\n    # and we can double check that the bind worked\n    # by requesting the instance directly\n    async with container.enter_scope(\"request\") as state:\n        db = await container.solve(\n            Dependent(DBProtocol), scopes=[\"request\"]\n        ).execute_async(\n            executor=AsyncExecutor(),\n            state=state,\n        )\n    assert isinstance(db, Postgres)\n</code></pre> <p>In this example we register the <code>Postgres</code> class to <code>DBProtocol</code>, and we can see that <code>di</code> auto-wires <code>Postgres</code> as well!</p> <p>Binds can be used as a direct function call, in which case they are permanent, or as a context manager, in which case they are reversed when the context manager exits.</p>"},{"location":"binds/#bind-hooks","title":"Bind hooks","text":"<p>Binding is implemented as hooks / callbacks: when we solve a dependency graph, every hook is called with every dependent and if the hook \"matches\" the dependent it returns the substitute dependency (otherwise it just returns <code>None</code>).</p> <p>This means you can implement any sort of matching you want, including:</p> <ul> <li>Matching by type (see <code>di.container.bind_by_type</code>)</li> <li>Matching by any subclass (<code>di.container.bind_by_type</code> using the <code>covariant=True</code> parameter)</li> <li>Custom logic, in the form of a bind hook (<code>Container.bind</code>)</li> </ul> <p>For example, to match by parameter name:</p> <pre><code>import inspect\nimport typing\nfrom dataclasses import dataclass\n\nfrom di import Container\nfrom di.api.dependencies import DependentBase\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n@dataclass\nclass Foo:\n    bar: str = \"bar\"\n\n\ndef match_by_parameter_name(\n    param: typing.Optional[inspect.Parameter], dependent: DependentBase[typing.Any]\n) -&gt; typing.Optional[DependentBase[typing.Any]]:\n    if param is not None and param.name == \"bar\":\n        return Dependent(lambda: \"baz\", scope=None)\n    return None\n\n\ncontainer = Container()\n\ncontainer.bind(match_by_parameter_name)\n\nsolved = container.solve(Dependent(Foo, scope=None), scopes=[None])\n\n\ndef main():\n    with container.enter_scope(None) as state:\n        foo = solved.execute_sync(executor=SyncExecutor(), state=state)\n    assert foo.bar == \"baz\"\n</code></pre>"},{"location":"cache/","title":"Dependency Cache","text":"<p>Often, you will have dependencies that share a sub dependency. For example, you probably only want to load your configuration from environment variables once and then re-use the same object in multiple dependencies. To avoid re-computing the shared dependency, <code>di</code> will cache shared dependencies.</p>"},{"location":"cache/#how-caching-works","title":"How caching works","text":"<p>Dependencies are cached by their cache key, computed in <code>Dependent.cache_key</code>. See dependents for more information on <code>Dependent.cache_key</code>. Dependencies are cached by default, but this behavior can be changed on a per-dependency basis using the <code>use_cache=False</code> parameter to <code>Dependent</code>.</p> <pre><code>from random import random\n\nfrom di import Container\nfrom di.dependent import Dependent, Marker\nfrom di.executors import SyncExecutor\nfrom di.typing import Annotated\n\n\ndef controller(\n    # no marker is equivalent to Dependent(object)\n    v1: object,\n    # the default value is use_cache=True\n    v2: Annotated[object, Marker(object, scope=\"request\")],\n    # but you can set use_cache=False\n    v3: Annotated[float, Marker(random, use_cache=False, scope=\"request\")],\n) -&gt; None:\n    assert v1 is v2\n    assert v1 is not v3 and v2 is not v3\n\n\ndef main() -&gt; None:\n    container = Container()\n    solved = container.solve(Dependent(controller, scope=\"request\"), scopes=[\"request\"])\n    with container.enter_scope(\"request\") as state:\n        solved.execute_sync(executor=SyncExecutor(), state=state)\n</code></pre>"},{"location":"cache/#caching-and-scopes","title":"Caching and scopes","text":"<p>Dependencies are cached within their scope and any inner scopes. Once a dependency's scope exits, it's cached value is discarded and the next time the scope is entered a fresh value will be computed.</p>"},{"location":"contributing/","title":"Developer setup","text":"<p>This is a pure Python project and should be straightforward to set up on Linux or MacOS. We do not support Windows for development, if you use Windows you'll have to use VSCode DevContainers or a similar solution.</p> <p>We use Poetry for dependency management, and most of the config is the pyproject.toml.</p> <p>Linting is done via git hooks, managed by pre-commit. The linters may change over time, but they are configured in our pre-commit-config.yaml.</p> <p>Most of the setup and interaction with these systems is encapsulated in our Makefile.</p>"},{"location":"contributing/#project-setup","title":"Project setup","text":"<p>First, fork the repo and then clone your fork:</p> <pre><code>$ git clone https://github.com/adriangb/di.git\n---&gt; 100%\n$ cd di\n</code></pre> <p>Now install the project dependencies. You will need Make installed along with a compatible Python version (currently, 3.9.X).</p> <p>To set up the project, simply run:</p> <pre><code>$ make init\n</code></pre> <p>This will create a <code>.venv</code> virtualenv that you can configure your IDE to use.</p>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>$ make test\n</code></pre> <p>Tests are run with pytest, so you can also run them manually or configure your IDE to run them. The tests are stored in the <code>tests/</code> directory.</p>"},{"location":"contributing/#running-linting","title":"Running linting","text":"<p>Linting will run automatically on every commit. To disable this, you can commit with <code>git commit --no-verify</code>.</p> <p>You can also run linting manually:</p> <pre><code>$ make lint\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>The docs are written as markdown and built with MkDocs. Both the docs and their source code are stored in the <code>docs/</code> directory.</p> <p>To preview the docs locally as you edit them, run</p> <pre><code>$ make docs-serve\n</code></pre> <p>All the code fragments in the docs are stored as <code>.py</code> files in <code>docs_src/</code>. These code fragments are tested as part of unit tests to ensure that the documentation stays up to date with the API.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>This project uses continuous integration and continuous delivery on a trunk based workflow. Every merge into <code>main</code> should be fully functional code in a releasable state. As part of your pull request, you should propose what type of change is being made and determine the right version bump appropriately. While conventional commits are appreciated as a means of communication, especially for the merge commit, they are not required or enforced. You are however required to bump the package version in pyproject.toml. Every commit into <code>main</code> needs a version bump so that a release can be made, even if it is a refactor or \"chore\" type change.</p> <p>Once your change is merged, the new docs and PyPi package will be released automatically. Every time a release is made on PyPi, a corresponding GitHub release will be created to correlate PyPi versions to git commits.</p>"},{"location":"dependents/","title":"Dependents and the DependentBase","text":"<p>Most of these docs use <code>Dependent</code> as the main marker for dependencies. But the container doesn't actually know about either of these two things! In fact, the container only knows about the <code>DependentBase</code>, which you can find in <code>di.api.dependencies</code>. <code>Dependent</code> is just one possible implementation of the <code>DependentBase</code>.</p> <p>You can easily build your own version of <code>Dependent</code> by inheriting from <code>Dependent</code> or <code>DependentBase</code>.</p> <p>Here is an example that extracts headers from requests:</p> <pre><code>import inspect\nfrom typing import Mapping, Optional, TypeVar\n\nfrom di import Container, bind_by_type\nfrom di.dependent import Dependent, Marker\nfrom di.executors import AsyncExecutor\nfrom di.typing import Annotated\n\n\nclass Request:\n    def __init__(self, headers: Mapping[str, str]) -&gt; None:\n        self.headers = {k.lower(): v for k, v in headers.items()}\n\n\nclass Header(Marker):\n    def __init__(self, alias: Optional[str]) -&gt; None:\n        self.alias = alias\n        super().__init__(call=None, scope=\"request\", use_cache=False)\n\n    def register_parameter(self, param: inspect.Parameter) -&gt; Dependent[str]:\n        if self.alias is not None:\n            name = self.alias\n        else:\n            name = param.name.replace(\"_\", \"-\")\n\n        def get_header(request: Annotated[Request, Marker()]) -&gt; str:\n            return param.annotation(request.headers[name])\n\n        return Dependent(get_header, scope=\"request\")\n\n\nT = TypeVar(\"T\")\n\nFromHeader = Annotated[T, Header(alias=None)]\n\n\nasync def web_framework() -&gt; None:\n    container = Container()\n\n    valid_request = Request(headers={\"x-header-one\": \"one\", \"x-header-two\": \"2\"})\n    with container.bind(\n        bind_by_type(Dependent(lambda: valid_request, scope=\"request\"), Request)\n    ):\n        solved = container.solve(\n            Dependent(controller, scope=\"request\"), scopes=[\"request\"]\n        )\n    with container.enter_scope(\"request\") as state:\n        await solved.execute_async(executor=AsyncExecutor(), state=state)  # success\n\n    invalid_request = Request(headers={\"x-header-one\": \"one\"})\n    with container.bind(\n        bind_by_type(Dependent(lambda: invalid_request, scope=\"request\"), Request)\n    ):\n        solved = container.solve(\n            Dependent(controller, scope=\"request\"), scopes=[\"request\"]\n        )\n\n    with container.enter_scope(\"request\") as state:\n        try:\n            await solved.execute_async(executor=AsyncExecutor(), state=state)  # fails\n        except KeyError:\n            pass\n        else:\n            raise AssertionError(\n                \"This call should have failed because x-header-two is missing\"\n            )\n\n\ndef controller(\n    x_header_one: FromHeader[str],\n    header_two_val: Annotated[int, Header(alias=\"x-header-two\")],\n) -&gt; None:\n    \"\"\"This is the only piece of user code\"\"\"\n    assert x_header_one == \"one\"\n    assert header_two_val == 2\n</code></pre> <p>Another good example of the flexibility provided by <code>DependentBase</code> is the implementation of JointDependent, which lets you schedule and execute dependencies together even if they are not directly connected by wiring:</p> <pre><code>from di import Container\nfrom di.dependent import Dependent, JoinedDependent\nfrom di.executors import SyncExecutor\n\n\nclass A:\n    ...\n\n\nclass B:\n    executed = False\n\n    def __init__(self) -&gt; None:\n        B.executed = True\n\n\ndef main():\n    container = Container()\n    dependent = JoinedDependent(\n        Dependent(A, scope=\"request\"),\n        siblings=[Dependent(B, scope=\"request\")],\n    )\n    solved = container.solve(dependent, scopes=[\"request\"])\n    with container.enter_scope(\"request\") as state:\n        a = solved.execute_sync(executor=SyncExecutor(), state=state)\n    assert isinstance(a, A)\n    assert B.executed\n</code></pre> <p>Here <code>B</code> is executed even though <code>A</code> does not depend on it. This is because <code>JoinedDependent</code> leverages the <code>DependentBase</code> interface to tell <code>di</code> that <code>B</code> is a dependency of <code>A</code> even if <code>B</code> is not a parameter or otherwise related to <code>A</code>.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#simple-example","title":"Simple Example","text":"<p>Here is a simple example of how <code>di</code> works:</p> <pre><code>from dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\nclass A:\n    ...\n\n\nclass B:\n    ...\n\n\n@dataclass\nclass C:\n    a: A\n    b: B\n\n\ndef main():\n    container = Container()\n    solved = container.solve(Dependent(C, scope=\"request\"), scopes=[\"request\"])\n    with container.enter_scope(\"request\") as state:\n        c = solved.execute_sync(executor=SyncExecutor(), state=state)\n    assert isinstance(c, C)\n    assert isinstance(c.a, A)\n    assert isinstance(c.b, B)\n</code></pre> <p>You will notice that <code>di</code> \"auto-wired\" <code>C</code>: we didn't have to tell it that <code>C</code> depends on <code>A</code> and <code>B</code>, or how to construct <code>A</code> and <code>B</code>, it was all inferred from type annotations.</p> <p>In the wiring and provider registration chapters, you'll see how you can customize this behavior to tell <code>di</code> how to inject things like abstract interfaces or function return values.</p>"},{"location":"examples/#in-depth-example","title":"In-depth example","text":"<p>With this background in place, let's dive into a more in-depth example.</p> <p>In this example, we'll look at what it would take for a web framework to provide dependency injection to its users via <code>di</code>.</p> <p>Let's start by looking at the User's code.</p> <pre><code>from typing import Any, Callable\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n\n\nclass App:\n    def __init__(self, controller: Callable[..., Any]) -&gt; None:\n        self.container = Container()\n        self.solved = self.container.solve(\n            Dependent(controller, scope=\"request\"),\n            scopes=[\"request\"],\n        )\n        self.executor = SyncExecutor()\n\n    def run(self, request: Request) -&gt; int:\n        with self.container.enter_scope(\"request\") as state:\n            return self.solved.execute_sync(\n                values={Request: request},\n                executor=self.executor,\n                state=state,\n            )\n\n\n# User code\nclass MyClass:\n    def __init__(self, request: Request) -&gt; None:\n        self.value = request.value\n\n    def add(self, value: int) -&gt; int:\n        return self.value + value\n\n\ndef controller(myobj: MyClass) -&gt; int:\n    return myobj.add(1)\n\n\ndef main() -&gt; None:\n    app = App(controller)\n    resp = app.run(Request(1))\n    assert resp == 2\n    resp = app.run(Request(2))\n    assert resp == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>As a user, you have very little boilerplate. In fact, there is not a single line of code here that is not transmitting information.</p> <p>Now let's look at the web framework side of things. This part can get a bit complex, but it's okay because it's written once, in a library.</p> <p>First, we'll need to create a <code>Container</code> instance. This would be tied to the <code>App</code> or <code>Router</code> instance of the web framework.</p> <pre><code>from typing import Any, Callable\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n\n\nclass App:\n    def __init__(self, controller: Callable[..., Any]) -&gt; None:\n        self.container = Container()\n        self.solved = self.container.solve(\n            Dependent(controller, scope=\"request\"),\n            scopes=[\"request\"],\n        )\n        self.executor = SyncExecutor()\n\n    def run(self, request: Request) -&gt; int:\n        with self.container.enter_scope(\"request\") as state:\n            return self.solved.execute_sync(\n                values={Request: request},\n                executor=self.executor,\n                state=state,\n            )\n\n\n# User code\nclass MyClass:\n    def __init__(self, request: Request) -&gt; None:\n        self.value = request.value\n\n    def add(self, value: int) -&gt; int:\n        return self.value + value\n\n\ndef controller(myobj: MyClass) -&gt; int:\n    return myobj.add(1)\n\n\ndef main() -&gt; None:\n    app = App(controller)\n    resp = app.run(Request(1))\n    assert resp == 2\n    resp = app.run(Request(2))\n    assert resp == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Next we solve all of our endpoints/controllers (in this case just a single one). This should happen once, maybe at application startup, and then you should save the <code>solved</code> object, which contains all the information necessary to execute the dependency (dependency being in this case the user's endpoint/controller function). This is very important for performance: we want to do the least amount of work possible for each incoming request.</p> <pre><code>from typing import Any, Callable\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n\n\nclass App:\n    def __init__(self, controller: Callable[..., Any]) -&gt; None:\n        self.container = Container()\n        self.solved = self.container.solve(\n            Dependent(controller, scope=\"request\"),\n            scopes=[\"request\"],\n        )\n        self.executor = SyncExecutor()\n\n    def run(self, request: Request) -&gt; int:\n        with self.container.enter_scope(\"request\") as state:\n            return self.solved.execute_sync(\n                values={Request: request},\n                executor=self.executor,\n                state=state,\n            )\n\n\n# User code\nclass MyClass:\n    def __init__(self, request: Request) -&gt; None:\n        self.value = request.value\n\n    def add(self, value: int) -&gt; int:\n        return self.value + value\n\n\ndef controller(myobj: MyClass) -&gt; int:\n    return myobj.add(1)\n\n\ndef main() -&gt; None:\n    app = App(controller)\n    resp = app.run(Request(1))\n    assert resp == 2\n    resp = app.run(Request(2))\n    assert resp == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Finally, we execute the endpoint for each incoming request:</p> <pre><code>from typing import Any, Callable\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    def __init__(self, value: int) -&gt; None:\n        self.value = value\n\n\nclass App:\n    def __init__(self, controller: Callable[..., Any]) -&gt; None:\n        self.container = Container()\n        self.solved = self.container.solve(\n            Dependent(controller, scope=\"request\"),\n            scopes=[\"request\"],\n        )\n        self.executor = SyncExecutor()\n\n    def run(self, request: Request) -&gt; int:\n        with self.container.enter_scope(\"request\") as state:\n            return self.solved.execute_sync(\n                values={Request: request},\n                executor=self.executor,\n                state=state,\n            )\n\n\n# User code\nclass MyClass:\n    def __init__(self, request: Request) -&gt; None:\n        self.value = request.value\n\n    def add(self, value: int) -&gt; int:\n        return self.value + value\n\n\ndef controller(myobj: MyClass) -&gt; int:\n    return myobj.add(1)\n\n\ndef main() -&gt; None:\n    app = App(controller)\n    resp = app.run(Request(1))\n    assert resp == 2\n    resp = app.run(Request(2))\n    assert resp == 3\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When we do this, we provide the <code>Request</code> instance as a value. This means that <code>di</code> does not introspect at all into the <code>Request</code> to figure out how to build it, it just hands the value off to anything that requests it. You can also directly register providers, which is covered in the provider registration section of the docs.</p> <p>You'll also notice the <code>executor</code> parameter. As you'll see in the [architecture] chapter, one of the fundamental design principles in <code>di</code> is to decouple wiring, solving and execution. This makes it trivial to, for example, enable concurrent execution of dependencies using threads, asynchronous task groups or any other execution paradigm you want.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Scopes are one of the fundamental concepts in dependency injection. Some dependency injection frameworks provide fixed scopes, for example:</p> <ul> <li>Singleton: only one instance is created</li> <li>Request: in web frameworks, this could be the lifetime of a request</li> <li>Prototype: re-initialized every time it is needed</li> </ul> <p><code>di</code> generalizes this concept by putting control of scopes into the hands of the users / implementers: a scope in <code>di</code> is identified by any hashable value (a string, enum, int, etc.) and entering / exiting scopes is handled via context managers:</p> <pre><code>async with container.enter_scope(\"app\"):\n    async with container.enter_scope(\"request\"):\n        async with container.enter_scope(\"foo, bar, baz!\"):\n</code></pre> <p>Scopes provide a framework for several other important features:</p> <ul> <li>Dependency lifespans</li> <li>Dependency value sharing</li> </ul> <p>Every dependency is linked to a scope. When a scope exits, all dependencies linked to it are destroyed (if they have teardown, the teardown is run) and their value is removed from the cache. This means that dependencies scoped to an outer scope cannot depend on dependencies scoped to an inner scope:</p> <pre><code>from di import Container\nfrom di.dependent import Dependent, Marker\nfrom di.typing import Annotated\n\n\nclass Request:\n    ...\n\n\nRequestDep = Annotated[Request, Marker(scope=\"request\")]\n\n\nclass DBConnection:\n    def __init__(self, request: RequestDep) -&gt; None:\n        ...\n\n\nDBConnDep = Annotated[DBConnection, Marker(scope=\"app\")]\n\n\ndef controller(conn: DBConnDep) -&gt; None:\n    ...\n\n\ndef framework() -&gt; None:\n    container = Container()\n    container.solve(Dependent(controller, scope=\"request\"), scopes=[\"app\", \"request\"])\n</code></pre> <p>This example will fail with <code>di.exceptions.ScopeViolationError</code> because an <code>DBConnection</code> is scoped to <code>\"app\"</code> so it cannot depend on <code>Request</code> which is scoped to <code>\"request\"</code>.</p> <p>The order of the scopes is determined by the <code>scopes</code> parameter to <code>Container.solve</code>. If you've used Pytest fixtures before, you're already familiar with these rules. In Pytest, a <code>\"session\"</code> scoped fixture cannot depend on a <code>\"function\"</code> scoped fixture.</p>"},{"location":"scopes/#overriding-scopes","title":"Overriding scopes","text":"<p>You may encounter situations where you don't want to make your users explicitly set the scope for each dependency. For example, Spring defaults dependencies to the \"singleton\" scope. Our approach is to give you a callback that gets information on the current context (the scopes passed to <code>Container.solve</code>, the current <code>DependentBase</code> and the scopes of all of it's sub-dependencies) where you can inject your own logic for determining the right scope. Some examples of this include:</p> <ul> <li>A fixed default scope. You ignore all of the inputs and return a fixed value. This allows you to emulate Spring's behavior by returning a \"singleton\" scope or FastAPI's behavior by returning a \"connection\"/\"request\" scope.</li> <li>Try to assign the outermost valid scope. If the dependency depends on a <code>\"request\"</code> sub-dependency, you can't assign a <code>\"singleton\"</code> scope, so you assign the <code>\"request\"</code> scope. If there are no sub-dependencies or they all have the <code>\"singleton\"</code> scope, then you can assign the <code>\"singleton\"</code> scope.</li> </ul> <p>Here is an example of the simpler fixed-default behavior:</p> <pre><code>import os\nfrom typing import Any, Sequence\n\nfrom di import Container\nfrom di.api.dependencies import DependentBase\nfrom di.api.scopes import Scope\nfrom di.dependent import Dependent, Marker\nfrom di.executors import AsyncExecutor\nfrom di.typing import Annotated\n\n\n# Framework code\nclass Request:\n    def __init__(self, domain: str) -&gt; None:\n        self.domain = domain\n\n\nasync def web_framework() -&gt; None:\n    container = Container()\n    container.bind(\n        lambda param, dependent: Dependent(Request, scope=\"request\", wire=False)\n        if dependent.call is Request\n        else None\n    )\n\n    def scope_resolver(\n        dep: DependentBase[Any],\n        subdep_scopes: Sequence[Scope],\n        scopes: Sequence[Scope],\n    ) -&gt; Scope:\n        if dep.scope is None:\n            return \"request\"\n        return dep.scope\n\n    solved = container.solve(\n        Dependent(controller, scope=\"request\"),\n        scopes=[\"singleton\", \"request\"],\n        scope_resolver=scope_resolver,\n    )\n    async with container.enter_scope(\"singleton\") as singleton_state:\n        os.environ[\"domain\"] = \"bar.example.com\"\n        async with container.enter_scope(\n            \"request\", state=singleton_state\n        ) as request_state:\n            status = await solved.execute_async(\n                values={Request: Request(\"bar.example.com\")},\n                executor=AsyncExecutor(),\n                state=request_state,\n            )\n            assert status == 200, status\n        os.environ[\"domain\"] = \"foo.example.com\"\n        async with container.enter_scope(\n            \"request\", state=singleton_state\n        ) as request_state:\n            status = await solved.execute_async(\n                values={Request: Request(\"foo.example.com\")},\n                executor=AsyncExecutor(),\n                state=request_state,\n            )\n            assert status == 200, status\n\n\n# get_domain_from_env gets the \"request\" scope\ndef get_domain_from_env() -&gt; str:\n    return os.environ[\"domain\"]\n\n\n# authorize gets the \"request\" scope\ndef authorize(\n    request: Request,\n    domain: Annotated[str, Marker(get_domain_from_env)],\n) -&gt; bool:\n    return request.domain == domain\n\n\nasync def controller(authorized: Annotated[bool, Marker(authorize)]) -&gt; int:\n    if authorized:\n        return 200\n    return 403\n</code></pre> <p>In this example we didn't provide a scope for <code>get_domain_from_env</code>, but <code>di</code> can see that it does not depend on anything with the <code>\"request\"</code> scope and so it gets assigned the <code>\"singleton\"</code> scope. On the other hand <code>authorize</code> does depend on a <code>Request</code> object, so it gets the <code>\"request\"</code> scope.</p>"},{"location":"solving/","title":"Solving","text":"<p>Solving a dependency means build a directed acyclic graph (DAG) of dependencies by inspecting sub dependencies and resolving binds. Once we solve a dependency, we can execute it without doing any introspection.</p> <p>Solving is done by the Container. The result of solving is stored in a <code>SolvedDependent</code> object which you can pass to <code>Container.execute_{sync,async}</code> to get back the result. The simplest form of executing a dependency is thus:</p> <pre><code>result = container.execute(container.solve(Dependent(lambda: 1)))\n</code></pre> <p>For a more comprehensive overview, see the architecture section.</p>"},{"location":"solving/#solveddependent","title":"SolvedDependent","text":"<p><code>di</code> lets you pre-solve your dependencies so that you don't have to run the solver each time you execute. This usually comes with a huge performance boost, but only works if you have a static dependency graph. In practice, this just means that solving captures the current binds and won't be updated if there are changes to binds. Note that you can still have values in your DAG change, just not the shape of the DAG itself.</p> <p>For example, here is a more advanced use case where the framework solves the endpoint and then provides the <code>Request</code> as a value each time the endpoint is called.</p> <p>This means that <code>di</code> does not do any reflection for each request, nor does it have to do dependency resolution.</p> <pre><code>from di import Container, SolvedDependent\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    ...\n\n\ndef web_framework():\n    container = Container()\n    solved = container.solve(Dependent(controller, scope=\"request\"), scopes=[\"request\"])\n    assert isinstance(solved, SolvedDependent)\n\n    with container.enter_scope(\"request\") as state:\n        solved.execute_sync(\n            values={Request: Request()}, executor=SyncExecutor(), state=state\n        )\n\n    dependencies = solved.dag.keys() - {solved.dependency}\n    assert all(isinstance(item, Dependent) for item in dependencies)\n    assert {dependent.call for dependent in dependencies} == {Request, MyClass}\n\n\n# User code\nclass MyClass:\n    ...\n\n\ndef controller(request: Request, myobj: MyClass) -&gt; None:\n    ...\n</code></pre>"},{"location":"solving/#getting-a-list-of-dependencies","title":"Getting a list of dependencies","text":"<p>You can easily list all dependencies in a dag via <code>SolvedDependent.dag.keys()</code>.</p> <pre><code>from di import Container, SolvedDependent\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\n# Framework code\nclass Request:\n    ...\n\n\ndef web_framework():\n    container = Container()\n    solved = container.solve(Dependent(controller, scope=\"request\"), scopes=[\"request\"])\n    assert isinstance(solved, SolvedDependent)\n\n    with container.enter_scope(\"request\") as state:\n        solved.execute_sync(\n            values={Request: Request()}, executor=SyncExecutor(), state=state\n        )\n\n    dependencies = solved.dag.keys() - {solved.dependency}\n    assert all(isinstance(item, Dependent) for item in dependencies)\n    assert {dependent.call for dependent in dependencies} == {Request, MyClass}\n\n\n# User code\nclass MyClass:\n    ...\n\n\ndef controller(request: Request, myobj: MyClass) -&gt; None:\n    ...\n</code></pre> <p>This lists all of the Dependents for the solved dependency.</p> <p>This means that you can create custom markers and easily enumerate them. For example, you might make a <code>Header</code> dependency and then want to know what headers are being requested by the controller, even if they are nested inside other dependencies:</p> <pre><code>from di import Dependent\n\nclass Header(Dependent[str]):\n    ...\n</code></pre> <p>See the dependents section for a more complete example of this.</p>"},{"location":"wiring/","title":"Wiring","text":"<p>Wiring is the act of \"connecting\" together dependencies.</p> <p>In <code>di</code>, wiring is handled by the <code>Dependent</code> API. The general idea is that <code>Container</code> accepts a <code>Dependent</code> and then asks it for it's sub-dependencies. These sub-dependencies are themselves <code>Dependent</code>s, and so the <code>Container</code> keeps asking them for their sub-dependenices until there are none.</p> <p>But how does <code>Dependent</code> know what it's dependencies are? Every <code>Dependent</code> has a <code>call</code> attribute which is a callable (a class, a function, etc.) that which can be introspected (usually with <code>inpsect.signature</code>) to find it's parameters. The from these parameters the <code>Dependent</code> determine's what it's dependencies are. But how do we go from a parameter <code>param: Foo</code> to a <code>Dependent</code>? There are actually several different mechanisms available:</p>"},{"location":"wiring/#autowiring","title":"Autowiring","text":"<p>Autowiring is available when the parameter's type annotation is a well-behaved type/class. Well behaved in this case just means that it's parameters can be understood by <code>di</code>, for example that they are type annotated and are uniquely identifiable (<code>param: int</code> won't work properly).</p> <p>Here is an example showing auto-wiring in action.</p> <p>Auto-wiring can work with dataclasses, even ones with a <code>default_factory</code>. In this example we'll load a config from the environment:</p> <pre><code>from dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import AsyncExecutor\n\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n\n\nclass DBConn:\n    def __init__(self, config: Config) -&gt; None:\n        self.host = config.host\n\n\nasync def endpoint(conn: DBConn) -&gt; None:\n    assert isinstance(conn, DBConn)\n\n\nasync def framework():\n    container = Container()\n    solved = container.solve(Dependent(endpoint, scope=\"request\"), scopes=[\"request\"])\n    async with container.enter_scope(\"request\") as state:\n        await solved.execute_async(executor=AsyncExecutor(), state=state)\n</code></pre> <p>What makes this \"auto-wiring\" is that we didn't have to tell <code>di</code> how to construct <code>DBConn</code>: <code>di</code> detected that <code>controller</code> needed a <code>DBConn</code> and that <code>DBConn</code> in turn needs a <code>Config</code> instance.</p> <p>This is the simplest option because you don't have to do anything, but it' relatively limited in terms of what can be injected.</p>"},{"location":"wiring/#autowiring-metadata","title":"Autowiring metadata","text":"<p>To execute a dependency, <code>di</code> needs both a callable target (a class, function, etc.) and some metadata, namely <code>scope</code> and <code>use_cache</code>.</p> <p>Autowiring can discover the callable target from type annotations, but it cannot infer the metadata. So metadata is just inherited from the parent dependency: in the example above, we declared <code>endpoint</code> as having a <code>\"request\"</code> scope, so all of the sub-dependencies that get auto-wired end up having the <code>\"request\"</code> scope.</p>"},{"location":"wiring/#dependency-markers","title":"Dependency markers","text":"<p>Dependency markers, in the form of <code>di.dependent.Marker</code> serve to hold information about a dependency, for example how to construct it or it's scope.</p> <p>Markers are generally useful when:</p> <ul> <li>Injecting a non-identifiable type, like a <code>list[str]</code></li> <li>Injecting the result of a function (<code>param: some_function</code> is not valid in Python)</li> <li>The type being injected is not well-behaved and you need to tell <code>di</code> how to construct it</li> <li>You want to attach metadata to the target (like explicitly setting the <code>scope</code>)</li> </ul> <p>Let's take our previous example and look at how we would have used markers if <code>DBConn</code> accepted a <code>host: str</code> parameter instead of our <code>Config</code> class directly:</p> <pre><code>from dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent, Marker\nfrom di.executors import SyncExecutor\nfrom di.typing import Annotated\n\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n\n\nclass DBConn:\n    def __init__(self, host: str) -&gt; None:\n        self.host = host\n\n\ndef inject_db(config: Config) -&gt; DBConn:\n    return DBConn(host=config.host)\n\n\ndef endpoint(conn: Annotated[DBConn, Marker(inject_db, scope=\"request\")]) -&gt; None:\n    assert isinstance(conn, DBConn)\n\n\ndef framework():\n    container = Container()\n    solved = container.solve(Dependent(endpoint, scope=\"request\"), scopes=[\"request\"])\n    with container.enter_scope(\"request\") as state:\n        solved.execute_sync(executor=SyncExecutor(), state=state)\n</code></pre> <p>All we had to do was tell <code>di</code> how to construct <code>DBConn</code> (by assigning the parameter a <code>Marker</code>) and <code>di</code> can do the rest. Note that we are still using autowiring for <code>endpoint</code> and <code>Config</code>, it's not all or nothing and you can mix and match styles.</p>"},{"location":"wiring/#a-note-on-annotated-pep-593","title":"A note on Annotated / PEP 593","text":"<p>Markers are set via PEP 593's Annotated. This is in contrast to FastAPIs use of markers as default values (<code>param: int = Depends(...)</code>). When FastAPI was designed, PEP 593 did not exist, and there are several advantages to using PEP 593's Annotated:</p> <ul> <li>Compatible with other uses of default values, like dataclass' <code>field</code> or Pydantic's <code>Field</code>.</li> <li>Non-invasive modification of signatures: adding <code>Marker(...)</code> in <code>Annotated</code> should be ignored by anything except <code>di</code>.</li> <li>Functions/classes can be called as normal outside of <code>di</code> and the default values (when present) will be used.</li> <li>Multiple markers can be used. For example, something like <code>Annotated[T, PydanticField(), Marker()]</code>.</li> </ul> <p>This last point is important because of the composability it provides:</p> <pre><code>from typing import TypeVar, Annotated\n\nfrom di import Marker\nfrom pydantic import Field\n\nT_int = TypeVar(\"T_int\", bound=int)\nPositiveInt = Annotated[T_int, Field(ge=0)]\n\nT = TypeVar(\"T\")\nDepends = Annotated[T, Marker()]\n\ndef foo(v: Depends[PositiveInt[int]]) -&gt; int:\n    return v\n</code></pre> <p>Note how we used type aliases to create stackable, reusable types. This means that while <code>Annotated</code> can sometimes be verbose, it can also be made very convenient with type aliases.</p>"},{"location":"wiring/#custom-types","title":"Custom types","text":"<p>If you are writing and injecting your own classes, you also have the option of putting the dependency injection metadata into the class itself, via the <code>__di_dependency__(cls) -&gt; Marker</code> protocol. This obviously doesn't work if you are injecting a 3rd party class you are importing (unless you subclass it).</p> <p>The main advantage of this method is that the consumers of this class (which may be your own codebase) don't have to apply markers everywhere or worry about inconsistent scopes (see scopes).</p> <p>For example, we can tell <code>di</code> constructing a class asynchronously`:</p> <pre><code>import inspect\nfrom dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import AsyncExecutor\n\n\nclass HTTPClient:\n    pass\n\n\n@dataclass\nclass B:\n    msg: str\n\n    @classmethod\n    def __di_dependency__(cls, param: inspect.Parameter) -&gt; \"Dependent[B]\":\n        # note that client is injected by di!\n        async def func(client: HTTPClient) -&gt; B:\n            # do an http request or something\n            return B(msg=f\"\ud83d\udc4b from {param.name}\")\n\n        return Dependent(func)\n\n\nasync def main() -&gt; None:\n    def endpoint(b: B) -&gt; str:\n        return b.msg\n\n    container = Container()\n    executor = AsyncExecutor()\n    solved = container.solve(Dependent(endpoint), scopes=(None,))\n    async with container.enter_scope(None) as state:\n        res = await solved.execute_async(executor=executor, state=state)\n        assert res == \"\ud83d\udc4b from b\"\n</code></pre> <p>This allows you to construct your class even if it depends on doing async work and it needs to refer to the class itself.</p> <p>If you only need to do async work and don't need access to the class, you don't need to use this and can instead just make your field depend on an asynchronous function:</p> <pre><code>from dataclasses import dataclass\n\nfrom di import Container\nfrom di.dependent import Dependent, Marker\nfrom di.executors import AsyncExecutor\nfrom di.typing import Annotated\n\n\nasync def get_msg() -&gt; str:\n    # make an http request or something\n    return \"\ud83d\udc4b\"\n\n\n@dataclass\nclass B:\n    msg: Annotated[str, Marker(get_msg)]\n\n\nasync def main() -&gt; None:\n    def endpoint(b: B) -&gt; str:\n        return b.msg\n\n    container = Container()\n    executor = AsyncExecutor()\n    solved = container.solve(Dependent(endpoint), scopes=(None,))\n    async with container.enter_scope(None) as state:\n        res = await solved.execute_async(executor=executor, state=state)\n        assert res == \"\ud83d\udc4b\"\n</code></pre> <p>Another way this is useful is to pre-declare scopes for a class. For example, you may only want to have one <code>UserRepo</code> for you entire app:</p> <pre><code>import inspect\n\nfrom di import Container\nfrom di.dependent import Dependent\nfrom di.executors import SyncExecutor\n\n\nclass UsersRepo:\n    @classmethod\n    def __di_dependency__(cls, param: inspect.Parameter) -&gt; \"Dependent[UsersRepo]\":\n        return Dependent(UsersRepo, scope=\"app\")\n\n\ndef endpoint(repo: UsersRepo) -&gt; UsersRepo:\n    return repo\n\n\ndef framework():\n    container = Container()\n    solved = container.solve(\n        Dependent(endpoint, scope=\"request\"), scopes=[\"app\", \"request\"]\n    )\n    executor = SyncExecutor()\n    with container.enter_scope(\"app\") as app_state:\n        with container.enter_scope(\"request\", state=app_state) as req_state:\n            repo1 = solved.execute_sync(executor=executor, state=req_state)\n        with container.enter_scope(\"request\", state=app_state) as req_state:\n            repo2 = solved.execute_sync(executor=executor, state=req_state)\n        assert repo1 is repo2\n</code></pre>"},{"location":"wiring/#injectableclass","title":"InjectableClass","text":"<p>As a convenience, <code>di</code> provides an <code>InjectableClass</code> type that you can inherit from so that you can easily pass parameters to <code>Marker</code> without implementing <code>__di_dependent__</code>:</p> <pre><code>from di import Container\nfrom di.dependent import Dependent, Injectable\nfrom di.executors import SyncExecutor\n\n\nclass UsersRepo(Injectable, scope=\"app\"):\n    pass\n\n\ndef endpoint(repo: UsersRepo) -&gt; UsersRepo:\n    return repo\n\n\ndef framework():\n    container = Container()\n    solved = container.solve(\n        Dependent(endpoint, scope=\"request\"), scopes=[\"app\", \"request\"]\n    )\n    executor = SyncExecutor()\n    with container.enter_scope(\"app\") as app_state:\n        with container.enter_scope(\"request\", state=app_state) as request_state:\n            repo1 = solved.execute_sync(executor=executor, state=request_state)\n        with container.enter_scope(\"request\"):\n            repo2 = solved.execute_sync(executor=executor, state=request_state)\n        assert repo1 is repo2\n</code></pre>"},{"location":"wiring/#binds","title":"Binds","text":"<p>Binds, which will be covered in depth in the binds section offer a way of swapping out dependencies imperatively (when you encounter type \"X\", use function \"y\" to build it). They can be used with any of the methods described above.</p>"},{"location":"wiring/#performance","title":"Performance","text":"<p>Reflection (inspecting function signatures for dependencies) is very slow. For this reason, <code>di</code> tries to avoid it as much as possible. The best way to avoid extra introspection is to re-use Solved Dependents.</p>"},{"location":"wiring/#conclusion","title":"Conclusion","text":"<p>There are several ways to declare dependencies in <code>di</code>. Which one makes sense for each use case depends on several factors, but ultimately they all achieve the same outcome.</p>"}]}